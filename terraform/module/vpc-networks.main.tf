resource "google_compute_network" "compute_networks" {
  for_each                = { for network in local.compute_networks : network.name => network }
  name                    = each.value.name
  project                 = each.value.project != null ? each.value.project : var.default_project
  auto_create_subnetworks = each.value.auto_create_subnetworks
}

resource "google_compute_subnetwork" "compute_subnetworks" {
  for_each      = { for subnetwork in local.compute_subnetworks : subnetwork.name => subnetwork }
  name          = each.value.name
  project       = each.value.project != null ? each.value.project : var.default_project
  ip_cidr_range = each.value.ip_cidr_range
  region        = each.value.region
  network       = google_compute_network.compute_networks[each.value.network_name].id
  dynamic "secondary_ip_range" {
    for_each = each.value.secondary_ip_ranges[*]
    content {
      range_name    = secondary_ip_range.value.range_name
      ip_cidr_range = secondary_ip_range.value.ip_cidr_range
    }
  }
}

resource "google_compute_network_peering" "compute_network_peerings" {
  for_each     = { for peering in local.compute_network_peerings : peering.name => peering }
  name         = each.value.name
  network      = google_compute_network.compute_networks[each.value.network_name].self_link
  peer_network = google_compute_network.compute_networks[each.value.peer_network_name].self_link

  export_custom_routes                = each.value.export_custom_routes
  import_custom_routes                = each.value.import_custom_routes
  export_subnet_routes_with_public_ip = each.value.export_subnet_routes_with_public_ip
  import_subnet_routes_with_public_ip = each.value.import_subnet_routes_with_public_ip
  # Debugging:
  #lifecycle {
  #  precondition {
  #    condition     = each.value.peer_network_name == "somethingelsethanthis"
  #    error_message = "each.value.peer_network_name is ${each.value.peer_network_name}"
  #  }
  #  #precondition {
  #  #  condition     = each.value.peer_network_name_postfix_disable == true
  #  #  error_message = "each.value.peer_network_name_postfix_disable == false"
  #  #}
  #  #precondition {
  #  #  condition     = each.value.peer_network_name_postfix_disable == false
  #  #  error_message = "each.value.peer_network_name_postfix_disable == true"
  #  #}
  #}
}

resource "google_compute_router" "autogenerated" {
  for_each = { for router in local.autogenerated_compute_routers : router.name => router }
  # When deploying networks and routers in one go, unless I add a depends_on I will 
  # without fail get errors about the network not being ready, and since you can't even 
  # depdescriptionend_on a single resource in a list of them, here we go:
  depends_on = [
    google_compute_network.compute_networks
  ]
  name    = each.value.name
  project = each.value.project != null ? each.value.project : var.default_project
  region  = each.value.region
  network = each.value.network

  bgp {
    asn = each.value.asn
  }
}

resource "google_compute_router_nat" "main" {
  for_each = { for cloud_nat in local.cloud_nats : cloud_nat.name => cloud_nat }
  # See comment at similar location in google_compute_router.autogenerated for 
  # why this is here:
  depends_on = [
    google_compute_router.autogenerated
  ]
  project = each.value.project != null ? each.value.project : var.default_project
  name    = each.value.name
  router  = each.value.router
  region  = each.value.region
  # TODO Make the rest of these options user-configurable
  nat_ip_allocate_option             = "AUTO_ONLY"
  source_subnetwork_ip_ranges_to_nat = "ALL_SUBNETWORKS_ALL_IP_RANGES"

  log_config {
    enable = false
    filter = "ERRORS_ONLY"
  }
}

resource "google_compute_firewall" "allow-internal" {
  for_each = { for network in local.compute_networks : network.name => network
    if(
      network.add_allow_internal_firewall_rule != null
      ? network.add_allow_internal_firewall_rule == true
      ? true
      : false
      : true
    )
  }
  project     = each.value.project != null ? each.value.project : var.default_project
  name        = "${each.value.name}-allow-internal"
  network     = resource.google_compute_network.compute_networks[each.value.name].self_link
  description = "Allows internal traffic within the network"
  direction   = "INGRESS"

  allow {
    protocol = "tcp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "udp"
    ports    = ["0-65535"]
  }

  allow {
    protocol = "icmp"
  }

  # TODO Create a map in locals that looks something like this:
  # network_cidr_ranges {
  #   "network_1_name" = [
  #     "primary range"
  #     "secondary range 0"
  #     "secondary range 1"
  #     "secondary range 2"
  #   ],
  #   ...
  # }
  source_ranges = [
    "10.2.0.0/16",
    "192.168.0.0/16", # Pods
    "10.244.0.0/16",  # Also pods
  ]
}

resource "google_compute_firewall" "iap-rules" {
  for_each = { for network in local.compute_networks : network.name => network
    if(
      network.add_iap_firewall_rule != null
      ? network.add_iap_firewall_rule == true
      ? true
      : false
      : true
    )
  }
  project     = each.value.project != null ? each.value.project : var.default_project
  name        = "${each.value.name}-allow-iap"
  network     = resource.google_compute_network.compute_networks[each.value.name].self_link
  description = "Allows access through IAP to instances tagged with allow-iap"

  allow {
    protocol = "tcp"
    ports    = ["22"]
  }

  source_ranges = ["35.235.240.0/20"]
  target_tags   = ["allow-iap"]
}
